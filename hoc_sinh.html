<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EmoMap AI - Ultimate Final</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <style>
        /* --- 1. GIAO DI·ªÜN CHUNG --- */
        :root { --primary: #ff9f43; --bg-color: #fff0e6; --chat-ai: #ffffff; --chat-text: #333; --shadow: 0 10px 30px rgba(0,0,0,0.1); --modal-bg: rgba(255,255,255,0.95); }
        body.dark-mode { --primary: #e67e22; --bg-color: #2d3436; --chat-ai: #636e72; --chat-text: #dfe6e9; --shadow: 0 10px 30px rgba(0,0,0,0.3); --modal-bg: rgba(45, 52, 54, 0.95); }
        
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; transition: background 0.3s, color 0.3s; }
        body { background-color: var(--bg-color); color: var(--chat-text); display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }

        .app-container { width: 100%; max-width: 450px; height: 95vh; background: rgba(255,255,255,0.8); backdrop-filter: blur(20px); border-radius: 30px; box-shadow: var(--shadow); display: flex; flex-direction: column; position: relative; overflow: hidden; border: 2px solid var(--primary); }
        body.dark-mode .app-container { background: rgba(45, 52, 54, 0.9); border-color: #555; }

        /* HEADER */
        .header { padding: 15px; background: var(--primary); color: white; display: flex; align-items: center; justify-content: space-between; z-index: 20; box-shadow: 0 5px 15px rgba(0,0,0,0.1); border-radius: 0 0 20px 20px; }
        .avatar-wrapper { display: flex; align-items: center; gap: 10px; } .kitty-icon { font-size: 1.8rem; } .theme-btn { background: none; border: none; color: white; font-size: 1.2rem; cursor: pointer; }

        /* CHAT AREA */
        .chat-area { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; scroll-behavior: smooth; }
        .msg { max-width: 80%; padding: 12px 18px; border-radius: 20px; font-size: 0.95rem; line-height: 1.5; word-wrap: break-word; animation: popIn 0.3s; }
        .msg.ai { align-self: flex-start; background: var(--chat-ai); color: var(--chat-text); border-bottom-left-radius: 5px; }
        .msg.user { align-self: flex-end; background: var(--primary); color: white; border-bottom-right-radius: 5px; }
        .typing { display: none; align-self: flex-start; background: var(--chat-ai); padding: 10px; border-radius: 20px; margin-left: 10px; width: fit-content; }
        .dot { display: inline-block; width: 6px; height: 6px; background: #bbb; border-radius: 50%; margin: 0 2px; animation: bounce 1.4s infinite; }
        
        /* INPUT AREA (ƒê√É S·ª¨A: TH√äM N√öT RESET V√ÄO ƒê√ÇY) */
        .input-area { padding: 15px; background: var(--chat-ai); border-top: 1px solid rgba(0,0,0,0.05); display: flex; gap: 8px; align-items: center; }
        input { flex: 1; padding: 12px; border: none; border-radius: 25px; outline: none; background: rgba(0,0,0,0.05); color: var(--chat-text); }
        
        .icon-btn { width: 42px; height: 42px; border-radius: 50%; border: none; background: var(--primary); color: white; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: 0.2s; font-size: 1rem; }
        .icon-btn:hover { transform: scale(1.1); }
        
        .reset-btn { background: #ff7675; } /* N√∫t Reset m√†u ƒë·ªè nh·∫°t */
        .mic-btn { background: #2ecc71; } /* N√∫t Mic m√†u xanh */
        .mic-btn.listening { animation: pulse 1s infinite; background: #e74c3c; }

        /* TOOLS BAR (CH·ªà C√íN 4 M·ª§C) */
        .tools-bar { display: grid; grid-template-columns: repeat(4, 1fr); background: var(--chat-ai); padding: 10px 0; }
        .tool-btn { background: none; border: none; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 5px; color: #888; font-size: 0.7rem; }
        .tool-btn:hover { color: var(--primary); transform: translateY(-3px); }
        .tool-btn i { font-size: 1.2rem; background: rgba(0,0,0,0.05); padding: 8px; border-radius: 12px; }

        /* MODALS */
        .modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: var(--modal-bg); z-index: 100; display: none; flex-direction: column; padding: 20px; animation: slideUp 0.3s; }
        .modal.active { display: flex; }
        .modal-header { display: flex; justify-content: space-between; margin-bottom: 20px; font-weight: bold; color: var(--primary); font-size: 1.3rem; }
        .close-btn { background: none; border: none; font-size: 2rem; cursor: pointer; color: var(--chat-text); padding: 0 10px; }

        /* --- GAME STYLE --- */
        #gameCanvas { 
            background: #202c3c; 
            border-radius: 15px; margin: 0 auto; display: block; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            touch-action: none;
            transition: background-color 0.5s ease;
        }
        .game-header-info { display: flex; justify-content: space-between; margin-bottom: 15px; color: white; font-weight: bold; }
        .score-box { background: #ff9f43; color:white; padding: 5px 15px; border-radius: 20px; box-shadow: 0 4px 0 #e67e22; display: flex; flex-direction: column; align-items: center; min-width: 100px;}
        .score-label { font-size: 0.7rem; opacity: 0.8; text-transform: uppercase; }
        .score-val { font-size: 1.2rem; }
        .best-score-box { background: #f1c40f; box-shadow: 0 4px 0 #d4ac0d; }

        .preview-container {
            display: flex; justify-content: space-around; margin-top: 20px;
            background: rgba(0,0,0,0.05); padding: 10px; border-radius: 15px;
        }
        .preview-canvas { width: 80px; height: 80px; background: transparent; touch-action: none; }

        #gameOverOverlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); color: white; padding: 30px;
            border-radius: 20px; text-align: center; z-index: 200;
            display: none; animation: popIn 0.5s; border: 3px solid #ff9f43; width: 80%;
        }
        .restart-btn {
            background: linear-gradient(to bottom, #ff9f43, #e67e22);
            color: white; border: none; padding: 12px 30px;
            border-radius: 25px; font-size: 1.1rem; font-weight: bold;
            cursor: pointer; margin-top: 20px; box-shadow: 0 5px 0 #d35400; 
        }
        .restart-btn:active { transform: translateY(5px); box-shadow: none; }

        /* OTHER STYLES */
        .map-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 20px; }
        .dot-map { width: 40px; height: 40px; border-radius: 50%; background: #eee; display: flex; justify-content: center; align-items: center; font-size: 0.7rem; color: white; font-weight: bold; }
        .therapy-item { background: rgba(0,0,0,0.03); padding: 15px; border-radius: 15px; margin-bottom: 15px; border-left: 5px solid var(--primary); display: flex; justify-content: space-between; align-items: center; }
        .therapy-btn-mini { background: var(--primary); color: white; border: none; padding: 8px 20px; border-radius: 20px; cursor: pointer; font-weight: bold; }
        
        #resetOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #a8e6cf, #dcedc1); z-index: 300; display: none; flex-direction: column; justify-content: center; align-items: center; color: #2d3436; }
        .reset-circle { width: 180px; height: 180px; border: 8px solid white; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 3rem; font-weight: bold; color: white; animation: breathe 8s infinite; }
        #sosOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #ff4d4d; z-index: 999; display: none; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; padding: 20px; animation: pulseRed 2s infinite; }
        .sos-btn { background: white; color: #ff4d4d; border: none; padding: 15px 30px; border-radius: 30px; font-weight: bold; font-size: 1.2rem; margin-top: 20px; cursor: pointer; text-decoration: none; display: inline-block;}
        
        /* POPUP H·ªåC SINH */
        .student-popup { position: absolute; bottom: 70px; left: 50%; transform: translateX(-50%); width: 90%; background: white; padding: 15px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); z-index: 50; display: none; animation: popIn 0.3s; text-align: center; border: 2px solid var(--primary); }
        .student-popup.active { display: block; }
        .send-love-btn { background: #ff7675; color: white; border: none; padding: 8px 20px; border-radius: 20px; cursor: pointer; font-weight: bold; display: flex; align-items: center; gap: 5px; margin: 0 auto; }
        .floating-heart { position: absolute; font-size: 1.5rem; color: #ff7675; animation: floatUp 1s ease-out forwards; pointer-events: none; }

        @keyframes popIn { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); } 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        @keyframes breathe { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulseRed { 0% { box-shadow: 0 0 0 0 rgba(255, 118, 117, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(255, 118, 117, 0); } }
        @keyframes pulseGreen { 0% { box-shadow: 0 0 0 0 rgba(0, 184, 148, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(0, 184, 148, 0); } }
        @keyframes pulseBlue { 0% { box-shadow: 0 0 0 0 rgba(116, 185, 255, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(116, 185, 255, 0); } }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-50px) scale(1.5); } }
        @keyframes shakeCanvas { 0% { transform: translate(0, 0); } 10% { transform: translate(-5px, -5px); } 20% { transform: translate(5px, 5px); } 30% { transform: translate(-5px, 5px); } 40% { transform: translate(5px, -5px); } 50% { transform: translate(0, 0); } }
        .shaking { animation: shakeCanvas 0.3s; }
    </style>
</head>
<body>

    <div class="app-container">
        <div class="header">
            <div class="avatar-wrapper">
                <i class="fas fa-cat kitty-icon"></i>
                <div style="margin-left: 10px;">
                    <div style="font-weight: bold; font-size: 1.1rem;">EmoMap AI</div>
                    <div style="font-size: 0.75rem; opacity: 0.9;" id="statusText">Tr·ª£ l√Ω c·∫£m x√∫c</div>
                </div>
            </div>
            <button class="theme-btn" onclick="toggleDarkMode()"><i class="fas fa-moon"></i></button>
        </div>

        <div class="chat-area" id="chatBox"></div>
        <div class="typing" id="typingIndicator"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
        
        <div class="input-area">
            <input type="text" id="userInput" placeholder="Nh·∫Øn tin..." autocomplete="off">
            
            <button class="icon-btn reset-btn" onclick="activateReset()" title="Reset T√¢m Tr√≠">
                <i class="fas fa-redo"></i>
            </button>

            <button class="icon-btn mic-btn" id="voiceBtn" onclick="startDictation()">
                <i class="fas fa-microphone"></i>
            </button>

            <button class="icon-btn" onclick="handleChat()">
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>

        <div class="tools-bar">
            <button class="tool-btn" onclick="openModal('statsModal')"><i class="fas fa-chart-line" style="color:#0984e3"></i> Th·ªëng k√™</button>
            <button class="tool-btn" onclick="openModal('therapyModal')"><i class="fas fa-heartbeat" style="color:#e84393"></i> Tr·ªã li·ªáu</button>
            <button class="tool-btn" onclick="openModal('gameModal')"><i class="fas fa-gamepad" style="color:#f1c40f"></i> Game</button>
            <button class="tool-btn" onclick="openModal('mapModal')"><i class="fas fa-users" style="color:#00b894"></i> L·ªõp h·ªçc</button>
        </div>

        <div class="modal" id="gameModal">
            <div class="modal-header">
                <span>üéÆ Block Blast</span>
                <button class="close-btn" onclick="closeModal('gameModal')">√ó</button>
            </div>
            <div class="game-header-info">
                <div class="score-box"><span class="score-label">ƒêi·ªÉm</span><span class="score-val" id="scoreVal">0</span></div>
                <div class="score-box best-score-box"><span class="score-label">K·ª∑ l·ª•c</span><span class="score-val" id="bestScoreVal">0</span></div>
            </div>
            <div style="position: relative;">
                <canvas id="gameCanvas" width="350" height="380"></canvas>
                <div id="gameOverOverlay"><h2>GAME OVER!</h2><p>ƒêi·ªÉm: <span id="finalScore">0</span></p><button class="restart-btn" onclick="resetGame()">CH∆†I L·∫†I</button></div>
            </div>
            <div class="preview-container">
                <canvas id="preview1" class="preview-canvas" width="80" height="80"></canvas>
                <canvas id="preview2" class="preview-canvas" width="80" height="80"></canvas>
                <canvas id="preview3" class="preview-canvas" width="80" height="80"></canvas>
            </div>
        </div>

        <div class="modal" id="statsModal"><div class="modal-header"><span>üìà Th·ªëng K√™</span><button class="close-btn" onclick="closeModal('statsModal')">√ó</button></div><div style="height:300px"><canvas id="emotionChart"></canvas></div></div>
        
        <div class="modal" id="mapModal">
            <div class="modal-header"><span>‚ù§Ô∏è M·∫°ng L∆∞·ªõi C·∫£m X√∫c</span><button class="close-btn" onclick="closeModal('mapModal')">√ó</button></div>
            <div class="map-grid" id="classMapGrid"></div>
            <div class="student-popup" id="studentPopup">
                <div class="popup-name" id="popupName">B·∫°n b√†n 3</div>
                <div class="popup-status" id="popupStatus">"ƒêang h∆°i m·ªát..."</div>
                <button class="send-love-btn" onclick="sendLove()"><i class="fas fa-heart"></i> G·ª≠i nƒÉng l∆∞·ª£ng</button>
            </div>
        </div>
        
        <div class="modal" id="therapyModal"><div class="modal-header"><span>üíä Tr·ªã Li·ªáu</span><button class="close-btn" onclick="closeModal('therapyModal')">√ó</button></div>
            <div class="therapy-item"><span>H√≠t th·ªü 4-7-8</span><button class="therapy-btn-mini" onclick="startExercise('breath')">T·∫≠p</button></div>
            <div class="therapy-item"><span>Th∆∞ gi√£n c·ªï vai</span><button class="therapy-btn-mini" onclick="startExercise('stretch')">T·∫≠p</button></div>
            <div class="therapy-item"><span>Grounding</span><button class="therapy-btn-mini" onclick="startExercise('grounding')">T·∫≠p</button></div>
        </div>
        
        <div id="resetOverlay"><h2>Th∆∞ gi√£n...</h2><div class="reset-circle" id="resetCount">30</div><button onclick="closeReset()" style="margin-top:20px; padding:10px 20px; border-radius:10px; border:none; cursor:pointer">Xong</button></div>
        <div id="sosOverlay"><div style="font-size:4rem">‚ö†Ô∏è</div><h2>C·∫¢NH B√ÅO</h2><p>H√£y li√™n h·ªá ng∆∞·ªùi th√¢n ngay!</p><a href="tel:111" class="sos-btn">G·ªçi 111</a><button onclick="document.getElementById('sosOverlay').style.display='none'" style="background:none; border:1px solid white; color:white; padding:10px; margin-top:20px; border-radius:10px; cursor:pointer;">ƒê√≥ng</button></div>
    </div>

    <script>
        // ============================================================
        // ‚ö†Ô∏è D√ÅN API KEY GROQ V√ÄO ƒê√ÇY
        const API_KEY = "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"; 
        // ============================================================

        const LINK_VUI = "https://open.spotify.com/embed/playlist/4lPLZ0npUWzSpeg0BPOVdp?si=UjYu0QMTTiudxfcW1kPKxg";
        const LINK_LOFI = "https://open.spotify.com/embed/playlist/0jSMk9A4W6wnFUkfrBuRaG?si=-W7y9Rc6Sxq_k6MhiTugRw";

        let messages = []; 
        let history = JSON.parse(localStorage.getItem('emotionHistory')) || []; 
        let audioCtx;
        let myChart = null;

        // --- KH·ªûI T·∫†O CHUNG ---
        window.onload = function() {
            renderClassMap();
            checkDarkMode();
            
            const greeting = "Ch√†o b·∫°n! M√¨nh c√≥ th·ªÉ gi√∫p g√¨ b·∫°n h√¥m nay? üò∫";
            addMessage(greeting, 'ai');
            
            const systemPrompt = `B·∫°n l√† EmoMap AI, m·ªôt nh√† t√¢m l√Ω h·ªçc l·ªói l·∫°c.
                NHI·ªÜM V·ª§ PH√ÇN T√çCH CHUY√äN S√ÇU:
                1. üß¨ **Emotion DNA:** X√°c ƒë·ªãnh "m√£ gen c·∫£m x√∫c" c·ªßa ng∆∞·ªùi d√πng (Nh·∫°y c·∫£m/Ki√™n c∆∞·ªùng/D·ªÖ t·ªïn th∆∞∆°ng).
                2. üß† **Fake Emotion Radar:** Ph√°t hi·ªán s·ª± m√¢u thu·∫´n gi·ªØa l·ªùi n√≥i "M√¨nh ·ªïn" v√† gi·ªçng vƒÉn bu·ªìn b√£.
                3. ‚è≥ **Emotion Forecasting:** D·ª± b√°o: "N·∫øu ti·∫øp t·ª•c suy nghƒ© n√†y, kh·∫£ nƒÉng cao b·∫°n s·∫Ω b·ªã burnout trong 2 ng√†y t·ªõi."
                4. üß© **Cognitive Distortion:** Ch·ªâ ra l·ªói t∆∞ duy (V√≠ d·ª•: "B·∫°n ƒëang t∆∞ duy tr·∫Øng-ƒëen, s·ª± th·∫≠t kh√¥ng t·ªá nh∆∞ v·∫≠y").
                5. ü™û **Emotion Mirror:** "N·∫øu m√¨nh l√† b·∫°n, m√¨nh c≈©ng s·∫Ω c·∫£m th·∫•y b·∫•t l·ª±c."
                6. üõë **Burnout Scanner:** C·∫£nh b√°o n·∫øu th·∫•y d·∫•u hi·ªáu ki·ªát s·ª©c c·∫£m x√∫c.

                QUY T·∫ÆC H√ÄNH X·ª¨:
                - N·∫øu ch·ªâ ch√†o h·ªèi -> Ch√†o l·∫°i th√¢n thi·ªán.
                - N·∫øu NGHE T·ª™ KH√ìA BU·ªíN/STRESS -> Ph√¢n t√≠ch nh·∫π nh√†ng r·ªìi h·ªèi: "C·∫≠u c√≥ mu·ªën nghe nh·∫°c Lofi ƒë·ªÉ th∆∞ gi√£n kh√¥ng?".
                - N·∫øu USER ƒê·ªíNG √ù NGHE NH·∫†C -> CH·ªà TR·∫¢ L·ªúI DUY NH·∫§T C·ª§M T·ª™: "PLAY_SPOTIFY_NOW".
                - Gi·ªçng vƒÉn: ·∫§m √°p, th·∫•u hi·ªÉu, chuy√™n nghi·ªáp nh∆∞ng g·∫ßn g≈©i.`;

            messages.push({ role: "system", content: systemPrompt });
            messages.push({ role: "assistant", content: greeting });
            document.getElementById('statusText').innerText = "Groq AI Online ‚ö°";

            initGameEngine(); 
        };

        // --- GAME ENGINE (BLOCK BLAST) ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GRID_ROWS = 8; const GRID_COLS = 8;
        const CELL_SIZE = 40;
        const GRID_OFFSET_X = 15; const GRID_OFFSET_Y = 30;
        const COLORS = ['#FFD700', '#FF4757', '#2ED573', '#1E90FF', '#FFA502', '#9b59b6', '#3498db'];

        let board = Array(GRID_ROWS).fill().map(() => Array(GRID_COLS).fill(0));
        let previewShapes = [null, null, null];
        let previewCanvases = [document.getElementById('preview1'), document.getElementById('preview2'), document.getElementById('preview3')];
        
        let particles = []; let floatingTexts = []; let score = 0; let bestScore = localStorage.getItem('blockBlastBestScore') || 0;
        let isGameOver = false; let draggingShape = null;
        let cleanBoardTimer = 0; let gameLoopId;

        const SHAPE_TEMPLATES = [
            { m: [[1]], c: 0 }, { m: [[1,1],[1,1]], c: 1 }, { m: [[1,1,1]], c: 2 }, { m: [[1],[1],[1]], c: 3 },
            { m: [[1,1],[1,0]], c: 4 }, { m: [[1,1,1],[0,1,0]], c: 0 }, { m: [[1,1,0],[0,1,1]], c: 1 }
        ];

        function initGameEngine() {
            if (canvas.width === 0) { canvas.width = 350; canvas.height = 380; }
            document.getElementById('bestScoreVal').innerText = bestScore;
            if (previewShapes.every(s => s === null)) spawnShapes();
            if (!gameLoopId) gameLoop();
            
            if (!canvas.hasAttribute('data-init')) {
                canvas.addEventListener('mousedown', handleInputStart);
                canvas.addEventListener('mousemove', handleInputMove);
                window.addEventListener('mouseup', handleInputEnd);
                
                canvas.addEventListener('touchstart', handleInputStart, {passive: false});
                canvas.addEventListener('touchmove', handleInputMove, {passive: false});
                window.addEventListener('touchend', handleInputEnd);
                
                previewCanvases.forEach((pCvs, index) => {
                    pCvs.addEventListener('mousedown', (e) => handleStart(e, index));
                    pCvs.addEventListener('touchstart', (e) => handleStart(e, index), {passive: false});
                });
                canvas.setAttribute('data-init', 'true');
            }
        }

        function spawnShapes() {
            for(let i=0; i<3; i++) {
                if(previewShapes[i] === null) {
                    const t = SHAPE_TEMPLATES[Math.floor(Math.random() * SHAPE_TEMPLATES.length)];
                    previewShapes[i] = { matrix: t.m, color: COLORS[t.c % COLORS.length], id: i };
                }
            }
            drawAllPreviews();
            checkGameOver();
        }

        function gameLoop() {
            if (!document.getElementById('gameModal').classList.contains('active')) {
                gameLoopId = null;
                return; 
            }
            update(); draw();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function update() {
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life -= 0.02; p.size *= 0.95;
                if(p.life <= 0) particles.splice(i, 1);
            }
            for(let i=floatingTexts.length-1; i>=0; i--) {
                let t = floatingTexts[i]; t.y -= 1.5; t.life -= 0.015;
                if(t.life <= 0) floatingTexts.splice(i, 1);
            }
            if(cleanBoardTimer > 0) cleanBoardTimer--;
        }

        function draw() {
            if(cleanBoardTimer > 0) {
                const hue = (Date.now() / 10) % 360;
                ctx.fillStyle = `hsl(${hue}, 40%, 20%)`; 
            } else {
                ctx.fillStyle = '#202c3c';
            }
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for(let r=0; r<GRID_ROWS; r++) {
                for(let c=0; c<GRID_COLS; c++) {
                    let x = GRID_OFFSET_X + c * CELL_SIZE; let y = GRID_OFFSET_Y + r * CELL_SIZE;
                    drawBlock3D(ctx, x, y, CELL_SIZE-4, '#16202c', true);
                    if(board[r][c]) drawBlock3D(ctx, x, y, CELL_SIZE-4, board[r][c]);
                }
            }

            if(draggingShape) {
                const {r, c} = getGridPos(draggingShape.x, draggingShape.y);
                if(canPlace(draggingShape.shapeData.matrix, r, c)) {
                    ctx.globalAlpha = 0.4;
                    drawShapeOnCanvas(ctx, draggingShape.shapeData, GRID_OFFSET_X + c*CELL_SIZE, GRID_OFFSET_Y + r*CELL_SIZE, CELL_SIZE);
                    ctx.globalAlpha = 1.0;
                }
                drawShapeOnCanvas(ctx, draggingShape.shapeData, draggingShape.x, draggingShape.y, CELL_SIZE);
            }

            particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(p.x, p.y, p.size, p.size); });
            ctx.globalAlpha = 1.0;
            floatingTexts.forEach(t => { ctx.fillStyle = t.color || 'white'; ctx.font = t.font || 'bold 24px Arial'; ctx.textAlign = "center"; ctx.fillText(t.text, t.x, t.y); });
        }

        function drawBlock3D(context, x, y, size, color, isEmpty = false) {
            if(isEmpty) { context.fillStyle = color; context.fillRect(x+2, y+2, size, size); context.strokeStyle = 'rgba(255,255,255,0.05)'; context.lineWidth = 1; context.strokeRect(x+2, y+2, size, size); return; }
            context.fillStyle = color; context.fillRect(x+2, y+2, size, size);
            context.fillStyle = 'rgba(255,255,255,0.4)'; context.fillRect(x+2, y+2, size, size/3);
            context.fillStyle = 'rgba(0,0,0,0.2)'; context.fillRect(x+2, y+size-size/4, size, size/4+2);
            context.strokeStyle = 'rgba(255,255,255,0.2)'; context.lineWidth = 2; context.strokeRect(x+2, y+2, size, size);
        }

        function drawShapeOnCanvas(context, shapeData, startX, startY, cellSize) {
            shapeData.matrix.forEach((row, i) => { row.forEach((val, j) => { if(val) drawBlock3D(context, startX + j * cellSize, startY + i * cellSize, cellSize-4, shapeData.color); }); });
        }

        function drawAllPreviews() {
            previewCanvases.forEach((pCanvas, i) => {
                const pCtx = pCanvas.getContext('2d'); pCtx.clearRect(0, 0, pCanvas.width, pCanvas.height);
                if(previewShapes[i]) {
                    const m = previewShapes[i].matrix; const pCellSize = 20;
                    const pX = (pCanvas.width - m[0].length * pCellSize) / 2;
                    const pY = (pCanvas.height - m.length * pCellSize) / 2;
                    drawShapeOnCanvas(pCtx, previewShapes[i], pX, pY, pCellSize);
                }
            });
        }

        function getGridPos(x, y) { return {r: Math.round((y - GRID_OFFSET_Y) / CELL_SIZE), c: Math.round((x - GRID_OFFSET_X) / CELL_SIZE)}; }
        function canPlace(matrix, r, c) {
            for(let i=0; i<matrix.length; i++) {
                for(let j=0; j<matrix[0].length; j++) {
                    if(matrix[i][j]) {
                        if(r+i < 0 || r+i >= GRID_ROWS || c+j < 0 || c+j >= GRID_COLS || board[r+i][c+j]) return false;
                    }
                }
            }
            return true;
        }

        function placeShape(shapeData, r, c) {
            shapeData.matrix.forEach((row, i) => { row.forEach((val, j) => { if(val) board[r+i][c+j] = shapeData.color; }); });
            addScore(shapeData.matrix.flat().reduce((a,b)=>a+b,0) * 10, draggingShape.x, draggingShape.y, false);
            checkLinesAndScore();
        }

        function checkLinesAndScore() {
            let rowsToClear = [], colsToClear = [];
            for(let r=0; r<GRID_ROWS; r++) if(board[r].every(cell => cell !== 0)) rowsToClear.push(r);
            for(let c=0; c<GRID_COLS; c++) if(board.every(row => row[c] !== 0)) colsToClear.push(c);
            let totalLines = rowsToClear.length + colsToClear.length;

            if(totalLines > 0) {
                canvas.style.animation = 'none'; canvas.offsetHeight; canvas.style.animation = 'shake 0.3s';
                rowsToClear.forEach(r => { for(let c=0; c<GRID_COLS; c++) { createParticles(c, r, board[r][c]); board[r][c] = 0; } });
                colsToClear.forEach(c => { for(let r=0; r<GRID_ROWS; r++) { createParticles(c, r, board[r][c]); board[r][c] = 0; } });
                let baseLineScore = 100; let multiLineMultiplier = totalLines === 1 ? 1 : (totalLines === 2 ? 2 : (totalLines === 3 ? 4 : 8));
                addScore(totalLines * baseLineScore * multiLineMultiplier, canvas.width/2, canvas.height/2, true);
                
                if(totalLines > 1) floatingTexts.push({x: canvas.width/2, y: 200, text: totalLines > 2 ? "AMAZING!" : "DOUBLE!", life: 1.5, color: '#f1c40f', font: 'bold 28px Arial'});
                
                if(isBoardEmpty()) {
                    cleanBoardTimer = 100;
                    floatingTexts.push({x: canvas.width/2, y: 150, text: "PERFECT CLEAR!", life: 2.0, color: '#00ff00', font: 'bold 30px Arial'});
                    addScore(500, canvas.width/2, 250, true);
                }
            }
        }

        function isBoardEmpty() { for(let r=0; r<GRID_ROWS; r++) for(let c=0; c<GRID_COLS; c++) if(board[r][c] !== 0) return false; return true; }
        function createParticles(c, r, color) { let x = GRID_OFFSET_X + c*CELL_SIZE + CELL_SIZE/2; let y = GRID_OFFSET_Y + r*CELL_SIZE + CELL_SIZE/2; for(let i=0; i<8; i++) particles.push({ x: x, y: y, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 1.0, color: color, size: Math.random()*8+4 }); }
        function addScore(val, x, y, isMajor) { score += val; document.getElementById('scoreVal').innerText = score; if(score > bestScore) { bestScore = score; localStorage.setItem('blockBlastBestScore', bestScore); document.getElementById('bestScoreVal').innerText = bestScore; } floatingTexts.push({ x: x, y: y, text: "+" + val, life: 1.0, font: isMajor ? 'bold 32px Arial' : 'bold 20px Arial', color: isMajor ? '#FFD700' : 'white' }); }
        function checkGameOver() { if(isGameOver) return; let canPlaceAny = false; for(let i=0; i<3; i++) { if(previewShapes[i]) { for(let r=0; r<GRID_ROWS; r++) { for(let c=0; c<GRID_COLS; c++) { if(canPlace(previewShapes[i].matrix, r, c)) { canPlaceAny = true; break; } } if(canPlaceAny) break; } } if(canPlaceAny) break; } if(!canPlaceAny && previewShapes.some(s => s !== null)) { isGameOver = true; document.getElementById('finalScore').innerText = score; document.getElementById('gameOverOverlay').style.display = 'block'; } }
        function resetGame() { board = Array(GRID_ROWS).fill().map(() => Array(GRID_COLS).fill(0)); score = 0; isGameOver = false; document.getElementById('scoreVal').innerText = 0; document.getElementById('gameOverOverlay').style.display = 'none'; previewShapes = [null, null, null]; spawnShapes(); }
        
        function handleInputStart(e) {}
        function handleStart(e, index) {
            if(isGameOver || !previewShapes[index]) return;
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const mainRect = canvas.getBoundingClientRect();
            draggingShape = { shapeData: previewShapes[index], previewIndex: index, x: clientX - mainRect.left - CELL_SIZE/2, y: clientY - mainRect.top - CELL_SIZE/2 };
            previewShapes[index] = null; drawAllPreviews();
        }
        function handleInputMove(e) {
            if(!draggingShape) return;
            e.preventDefault();
            const mainRect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            draggingShape.x = clientX - mainRect.left - CELL_SIZE/2;
            draggingShape.y = clientY - mainRect.top - CELL_SIZE;
        }
        function handleInputEnd(e) {
            if(!draggingShape) return;
            const {r, c} = getGridPos(draggingShape.x, draggingShape.y);
            if(canPlace(draggingShape.shapeData.matrix, r, c)) {
                placeShape(draggingShape.shapeData, r, c);
                if(previewShapes.every(s => s === null)) spawnShapes(); else checkGameOver();
            } else { previewShapes[draggingShape.previewIndex] = draggingShape.shapeData; drawAllPreviews(); }
            draggingShape = null;
        }

        // --- CHAT & OTHER LOGIC ---
        async function handleChat() {
            const input = document.getElementById('userInput'); const text = input.value.trim(); if(!text) return;
            const SOS_WORDS = ["t·ª± t·ª≠", "mu·ªën ch·∫øt", "t·ª± s√°t", "r·∫°ch tay", "nh·∫£y l·∫ßu"];
            if(SOS_WORDS.some(kw => text.toLowerCase().includes(kw))) { document.getElementById('sosOverlay').style.display='flex'; input.value=''; return; }
            addMessage(text, 'user'); input.value = ''; document.getElementById('typingIndicator').style.display = 'block'; messages.push({ role: "user", content: text });
            try { const aiText = await callGroqAPI(messages); document.getElementById('typingIndicator').style.display = 'none'; messages.push({ role: "assistant", content: aiText }); processResponse(aiText, text); } catch (error) { document.getElementById('typingIndicator').style.display = 'none'; addMessage("‚ö†Ô∏è L·ªói: " + error.message, 'ai'); }
        }
        async function callGroqAPI(msgs) {
            const response = await fetch("https://api.groq.com/openai/v1/chat/completions", { method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${API_KEY}` }, body: JSON.stringify({ model: "llama-3.3-70b-versatile", messages: msgs, temperature: 0.7 }) });
            if (!response.ok) throw new Error((await response.json()).error.message); return (await response.json()).choices[0].message.content;
        }
        function processResponse(text, userText) { if (text.includes("PLAY_SPOTIFY_NOW")) { addMessage("Oki! Nh·∫°c l√™n. üé∂", 'ai'); const t = userText.toLowerCase(); let link = LINK_LOFI; if (t.includes("vui") || t.includes("tuy·ªát")) link = LINK_VUI; addMessage(`<iframe style="border-radius:12px; margin-top:10px;" src="${link}" width="100%" height="152" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>`, 'ai'); } else { addMessage(text.replace(/\*\*/g, ''), 'ai'); } const t = userText.toLowerCase(); let score = 5; if(t.includes('bu·ªìn')||t.includes('kh√≥c')) { changeTheme('sad'); score=2; } else if(t.includes('vui')||t.includes('tuy·ªát')) { changeTheme('happy'); score=10; } else if(t.includes('cƒÉng')||t.includes('lo')) { changeTheme('stress'); score=1; } saveHistory(userText, score); }
        function addMessage(h,t){ const b=document.getElementById('chatBox'); const d=document.createElement('div'); d.className=`msg ${t}`; d.innerHTML=h; b.appendChild(d); b.scrollTop=b.scrollHeight; }
        function openModal(id) { document.querySelectorAll('.modal').forEach(m => m.classList.remove('active')); const m = document.getElementById(id); if(m) { m.classList.add('active'); if(id === 'statsModal') renderChart(); if(id === 'gameModal') initGameEngine(); } }
        function closeModal(id) { const m = document.getElementById(id); if(m) m.classList.remove('active'); }
        function toggleDarkMode() { document.body.classList.toggle('dark-mode'); localStorage.setItem('kitty_darkMode', document.body.classList.contains('dark-mode')); document.querySelector('.theme-btn i').className = document.body.classList.contains('dark-mode') ? 'fas fa-sun' : 'fas fa-moon'; }
        function checkDarkMode() { if(localStorage.getItem('kitty_darkMode') === 'true') toggleDarkMode(); }
        function startDictation() { if (window.hasOwnProperty('webkitSpeechRecognition')) { var recognition = new webkitSpeechRecognition(); recognition.lang = "vi-VN"; const btn = document.getElementById('voiceBtn'); btn.classList.add('listening'); recognition.start(); recognition.onresult = function(e) { document.getElementById('userInput').value = e.results[0][0].transcript; recognition.stop(); btn.classList.remove('listening'); }; } else { alert("D√πng Chrome ƒë·ªÉ n√≥i."); } }
        function saveHistory(text, score) { history.push({ time: new Date().toLocaleTimeString(), text: text, score: score }); if(history.length > 20) history.shift(); localStorage.setItem('emotionHistory', JSON.stringify(history)); }
        function renderChart() { const ctx = document.getElementById('emotionChart').getContext('2d'); if(myChart) myChart.destroy(); myChart = new Chart(ctx, { type: 'line', data: { labels: history.map(h => h.time), datasets: [{ label: 'C·∫£m x√∫c', data: history.map(h => h.score), borderColor: '#ff9f43', backgroundColor: 'rgba(255, 159, 67, 0.2)', tension: 0.4, fill: true }] } }); }
        function renderClassMap(){ const g=document.getElementById('classMapGrid'); g.innerHTML=''; 
            for(let i=0; i<19; i++){ let d=document.createElement('div'); d.className='dot-map'; 
            d.style.background=['#00b894','#ff7675','#74b9ff'][Math.floor(Math.random()*3)]; 
            d.onclick = () => showStudentInfo(i+1);
            g.appendChild(d); } 
        }
        function showStudentInfo(id) { 
            const pop = document.getElementById('studentPopup'); 
            document.getElementById('popupName').innerText=`B·∫°n b√†n ${id}`; 
            pop.classList.add('active'); 
        }
        function sendLove(){ document.getElementById('studentPopup').classList.remove('active'); alert("ƒê√£ g·ª≠i tim! ‚ù§Ô∏è"); }
        function initAudio(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }
        function playWhiteNoise(){ initAudio(); const b=audioCtx.createBuffer(1, audioCtx.sampleRate*2, audioCtx.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; whiteNoiseSource=audioCtx.createBufferSource(); whiteNoiseSource.buffer=b; whiteNoiseSource.loop=true; const g=audioCtx.createGain(); g.gain.value=0.1; whiteNoiseSource.connect(g); g.connect(audioCtx.destination); whiteNoiseSource.start(); }
        function stopWhiteNoise(){ if(whiteNoiseSource){ whiteNoiseSource.stop(); whiteNoiseSource=null; } }
        let resetInt;
        window.activateReset=function(){ document.getElementById('resetOverlay').style.display='flex'; try{playWhiteNoise();}catch(e){} let t=30; resetInt=setInterval(()=>{ t--; document.getElementById('resetCount').innerText=t; if(t<=0) closeReset(); },1000); }
        window.closeReset=function(){ clearInterval(resetInt); document.getElementById('resetOverlay').style.display='none'; stopWhiteNoise(); addMessage("Ch√†o m·ª´ng c·∫≠u quay l·∫°i! üåø", 'ai'); }
        window.startExercise=function(t){ closeModal('therapyModal'); addMessage(t==='breath'?"üå¨Ô∏è H√≠t 4s - Gi·ªØ 7s - Th·ªü 8s":t==='stretch'?"üôÜ Nghi√™ng ƒë·∫ßu 10s":"üëÅÔ∏è T√¨m 5 v·∫≠t nh√¨n th·∫•y", 'ai'); }
        document.getElementById('userInput').addEventListener("keypress", e=>{if(e.key==="Enter") handleChat()});
    </script>
</body>
</html>

